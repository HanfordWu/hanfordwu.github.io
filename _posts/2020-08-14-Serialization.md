### I. Meaning of Serialization

- Serialization: Write objects into I/O stream.
- DeSerialization: Read objects from I/O stream.
- Usage: RMI(Remote method invoke), the incoming parameter and outgoing result must be **Serializable**

Serialization is to store the information of an object, including all non-static data member values that declared in the class, not includes data member inherited from super class. If the member is a reference(not primary type or string), the referred object must be Serializable.

DeSerialization needs the .class(.java) we want to extract, so that JVM is able to create a new object and append extracted information to the object.

### II. How to?

The class must implement **Serializable** or **Externalizable** interface

#### 1. Serializable

##### 1.1 Normal Serialization

Steps of serialization:
- Create `ObjectOutputStream`;
- Call `ObjectOutputStream.writeObject(obj)`;

```java
public class Person implements Serializable {  private String name;  private int age;  //我不提供无参构造器  public Person(String name, int age) {      this.name = name;      this.age = age;  }  @Override  public String toString() {      return "Person{" +              "name='" + name + '\'' +              ", age=" + age +              '}';  }}public class WriteObject {  
    public static void main(String[] args) {      
        try (//创建一个ObjectOutputStream输出流
          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.txt"))) {          
            //将对象序列化到文件s          
            Person person = new Person("9龙", 23);
            oos.writeObject(person);
            } catch (Exception e) 
            {          
                e.printStackTrace();            
            }  
        }
}
```

Steps of DeSerialization:
- Create an `ObjectInputStream`;
- Call `ObjectInputStream.readObject()` one by one (if a file has multiple objects).

```java
public class Person implements Serializable {  
    private String name;  private int age;  
    //我不提供无参构造器  
    public Person(String name, int age) {      
        System.out.println("反序列化，你调用我了吗？");
              this.name = name;
              this.age = age; 
         }
          @Override  public String toString() {      
            return "Person{" 
            +              "name='" 
            + name + '\'' 
            +              ", age=" 
            + age 
            +              '}';  
            }
            }
            public class ReadObject {  
                public static void main(String[] args) {      
                    try (
                        //创建一个ObjectInputStream输入流           
                        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.txt"))) {          
                            Person brady = (Person) ois.readObject();
                                  System.out.println(brady);
                              } catch (Exception e) {          
                            e.printStackTrace();      
                            }  
                            }}
                            //输出结果
                            //Person{name='9龙', age=23}
```

From the output, DeSerialization doesn't call object's constructor, the read object is generated by JVM, not constructor.


##### 1.2 Referenced data member Serialization

If a data member is not primary type, nor String, the referred object must be also Serializable, otherwise, we cannot serialize it.

```java
public class Person{    
    //省略相关属性与方法
    }public class Teacher implements Serializable {    
        private String name;
        private Person person;
        public Teacher(String name, Person person) {        
        this.name = name;
        this.person = person;    
        }     
    public static void main(String[] args) throws Exception {        
    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("teacher.txt"))) {            
    Person person = new Person("路飞", 20);
    Teacher teacher = new Teacher("雷利", person);            
    oos.writeObject(teacher);        
    }    
    }
}
```
Output:
```java
Exception in thread "main" java.io.NotSerializableException: Person
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)
	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)
	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)
	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)
	at Main.main(Main.java:20)
```

##### 1.3 Serialize one object multiple times

If serialize one object multiple times, only the first time works. because for each object, it has a uid, Java serialize objects according to UID, one uid number only serialize one time in one stream.

So that in one stream, two different object should have different UID.

In one stream, two objects are referring one same Serializable object, the third object will be serialized only once.

```java
public class WriteTeacher {    
    public static void main(String[] args) throws Exception {        
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("teacher.txt"))) {            
            Person person = new Person("路飞", 20);            
            Teacher t1 = new Teacher("雷利", person);            
            Teacher t2 = new Teacher("红发香克斯", person);            
            //依次将4个对象写入输入流            
            oos.writeObject(t1);            
            oos.writeObject(t2);            
            oos.writeObject(person);            
            oos.writeObject(t2);        
            }    
        }}
```

Serialize t1, t2, person, t2, to teacher.txt file.

Then DeSerialization, it's better deserialize on sequence.

```java
public class ReadTeacher {    
    public static void main(String[] args) {        
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("teacher.txt"))) {            
            Teacher t1 = (Teacher) ois.readObject();            
            Teacher t2 = (Teacher) ois.readObject();            
            Person p = (Person) ois.readObject();            
            Teacher t3 = (Teacher) ois.readObject();            
            System.out.println(t1 == t2);            
            System.out.println(t1.getPerson() == p);            
            System.out.println(t2.getPerson() == p);            
            System.out.println(t2 == t3);            
            System.out.println(t1.getPerson() == t2.getPerson());        } 
            catch (Exception e) {            
                e.printStackTrace();        
            }    
        }
    }
//输出结果
//false
//true
//true
//true
//true
```

Note:
- All Serializable objects have a UID
- Before serialization, JVM check if the UID has been serialized, only once in one stream.
- If one object has been serialized, stream will output the number.

![alt](https://kgpqsq.ch.files.1drv.com/y4mn7oNvW30tcpI0VFfmcd1R-qEIgLC9zuAdiIouG7156HaOJy0gTEsrKdvweueOimqTMsy06Rlr_kawiu_yxj_meZfm6wEcpkESArl0MUciXrYmdmHCnzgQbfQ75Bq9yMXkeS48Jqc4flePvem2czrQ8F5rnX2kXZxDn1d3Ti8dfMhzmh6R-g5O33ztuisUzxd0FLMKishVzsKSqgmsXo8vg?width=396&height=442&cropmode=none)

##### 1.4 Problem of serialization

Because it doesn't serialize one object twice in one stream, if the object change it's property after first time serialization, it will not be changed in serialized file.

```java
public class WriteObject {    
    public static void main(String[] args) {        
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"));             
        ObjectInputStream ios = new ObjectInputStream(new FileInputStream("person.txt"))) {            
            //第一次序列化person            
            Person person = new Person("9龙", 23);            
            oos.writeObject(person);            
            System.out.println(person);            
            //修改name            
            person.setName("海贼王");            
            System.out.println(person);            
            //第二次序列化person            
            oos.writeObject(person);            
            //依次反序列化出p1、p2            
            Person p1 = (Person) ios.readObject();            
            Person p2 = (Person) ios.readObject();            
            System.out.println(p1 == p2);            
            System.out.println(p1.getName().equals(p2.getName()));        
            } catch (Exception e) {            
                e.printStackTrace();        
                }    
            }}
//输出结果
//Person{name='9龙', age=23}
//Person{name='海贼王', age=23}
//true
//true
```

##### 1.5 Customized Serialization

1. `transient` keyword to exclude fields that don't need serialization:

```java
public class Person implements Serializable {   
    //不需要序列化名字与年龄   
    private transient String name;   
    private transient int age;   
    private int height;   
    private transient boolean singlehood;   
    public Person(String name, int age) {       
        this.name = name;       
        this.age = age;   
        }   
        //省略get,set方法
        }
public class TransientTest {   
            public static void main(String[] args) throws Exception {       
                try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"));            
                ObjectInputStream ios = new ObjectInputStream(new FileInputStream("person.txt"))) {           
                    Person person = new Person("9龙", 23);           
                    person.setHeight(185);           
                    System.out.println(person);           
                    oos.writeObject(person);           
                    Person p1 = (Person)ios.readObject();           
                    System.out.println(p1);       
                    }   
                    }}
//输出结果
//Person{name='9龙', age=23', singlehood=true', height=185cm}
//Person{name='null', age=0', singlehood=false', height=185cm}
```

`singlehood` is transient, serialization ignore it, but when do DeSerialization, it become default value `false`. For reference type, default is null, primary type, default is 0, boolean type, default is false.

2. Second way to customize serialization.

We can override `writeObject()` and `readObject()`, select attributes that we want to serialize. We can also encrypt the bytes we serialized, then decrypt when DeSerialization.

For example, we reverse a String, then serialized it, then deserialize it, and reverse back to get correct String.

```java
public class Person implements Serializable {   
    private String name;   
    private int age;   
    //省略构造方法，get及set方法   
    private void writeObject(ObjectOutputStream out) throws IOException {       
        //将名字反转写入二进制流       
        out.writeObject(new StringBuffer(this.name).reverse());       
        out.writeInt(age);   }   
        private void readObject(ObjectInputStream ins) throws IOException,ClassNotFoundException{       
            //将读出的字符串反转恢复回来       
            this.name = ((StringBuffer)ins.readObject()).reverse().toString();       
            this.age = ins.readInt();   
            }}
```

3. Radical serialization 

Inside of serialization, it first call `writeReplace()`/`readResolve()` before call `writeObject()`/`readObject`, so we can replace the object that we are going to serialize to do more things.

#### 2. Externalizable

Serialize object by implementing `Externalizable`, overriding `writeExternal` and `readExternal` methods.


#### 3. Comparison

|Serializable Interface | Externalizable Interface
|----------|-------------
System store necessary information automatically | Programmer determine what to store |
Java inner support, easy to use | Have to override two methods|
less performance | better performance|



### III. serialVersionUID

In above code, we didn't specify the `private static final long serialVersionUID`, but actually, compiler help us to add a UID behind, like a version number, once we change the class's code, the compiler change the UID.

Image after we do serialization, then we change the class's code, then we cannot deserialize the object information back to latest class, because the UID of serialized object is different from the new version .class we are doing DeSerialization.

Therefore, if we want to be able to deserialize the object information after we change the class code, we have to give the class a fixed UID.

```java
public class Person implements Serializable {    
    //序列化版本号    
    private static final long serialVersionUID = 1111013L;    
    private String name;    
    private int age;    
    //省略构造方法及get,set
}
```

If don't have `private static final long serialVersionUID = 1111013L;` We add one more attribute: `private String habit;`, we cannot deserialize the stored `name` and `age` information.

**Do we need to change UID?**
- If only change the methods, DeSerialization is not affected we don't have to change the UID;
- If only modify `transient` attribute or static attribute, DeSerialization is not affected, we don't have to change the UID;
- If we modify the normal private member's type, name, the DeSerialization will be failed, so we need to change the UID to avoid error.
- If just add/remove new attribute, we don't change UID.

IV. Conclusion

- All objects that are going to be transmitted on network need to implement Serializable. Recommend all javaBean.
- Objects' className, instance variables will be serialized. Methods, class variables, transient variables won't.
- Serializable objects' reference attributes should be also Serializable.
- DeSerialization needs the .class that we want to deserialize.
- DeSerialization should be on sequence of serialization.
- Singleton object should override `readResolve()` method, otherwise it will violate Singleton, because DeSerialization is creating new objects.
- Recommend all Serializable class have serialVersionUID, good for code upgrade.